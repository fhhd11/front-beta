# Исправление проблем с Railway деплоем

## Дата: 08.10.2025

## Описание проблем

1. **Бесконечная индикация "агент печатает"**: После отправки сообщения индикатор "агент печатает..." висел бесконечно, ответ не появлялся без перезагрузки страницы
2. **Дублирование сообщений**: После перезагрузки страницы отправлялось 2 одинаковых сообщения и приходило 2 ответа

## Исправления

### 1. Исправлена очистка временных сообщений (`src/composables/useChat.js`)

**Проблема**: В функции `sendMessageLegacy` (используется по умолчанию) временные сообщения с флагами `isTemporary` и `isTyping` не удалялись после загрузки реальных сообщений из API.

**Решение**:
- Добавлена фильтрация временных сообщений после успешной загрузки:
  ```javascript
  messages.value = messages.value.filter(msg => 
    !msg.isTemporary && !msg.isTyping
  )
  ```
- Улучшена обработка ошибок с правильной очисткой временных сообщений

### 2. Исправлено дублирование при загрузке сообщений

**Проблема**: `watch` хук для `lettaAgentId` срабатывал несколько раз при инициализации, вызывая множественную загрузку сообщений.

**Решение**:
- Добавлена проверка реального изменения агент ID:
  ```javascript
  if (newAgentId && isAuthenticated.value && newAgentId !== oldAgentId)
  ```

### 3. Улучшена обработка SSE соединений (`src/utils/sseClient.js`)

**Проблема**: SSE соединение не всегда корректно закрывалось при завершении потока.

**Решение**:
- Добавлен `finally` блок для гарантированной очистки ресурсов
- Автоматический триггер события `done` при завершении потока
- Улучшено логирование для отладки

### 4. Улучшена функция очистки стриминга

**Решение**:
- Добавлена обработка ошибок при отключении SSE клиента
- Добавлено логирование для отладки процесса очистки

## Как тестировать

1. **Проверка индикатора "агент печатает"**:
   - Отправьте сообщение в чат
   - Убедитесь, что индикатор "агент печатает..." появляется
   - Проверьте, что индикатор исчезает после получения ответа
   - Ответ должен появиться автоматически без перезагрузки страницы

2. **Проверка дублирования сообщений**:
   - Отправьте несколько сообщений
   - Перезагрузите страницу (F5)
   - Убедитесь, что в истории чата нет дублированных сообщений
   - Отправьте новое сообщение после перезагрузки
   - Проверьте, что отправляется только одно сообщение и приходит только один ответ

3. **Проверка на Railway**:
   - Задеплойте изменения на Railway
   - Протестируйте функциональность в production окружении
   - Откройте консоль браузера (F12) и проверьте логи на наличие ошибок

## Технические детали

### Измененные файлы:
- `src/composables/useChat.js` - основные исправления логики чата
- `src/utils/sseClient.js` - улучшения обработки SSE потока

### Режим работы:
По умолчанию используется **non-streaming режим** (`sendMessageLegacy`), который:
1. Отправляет сообщение на API
2. Показывает временные UI элементы (сообщение пользователя + индикатор typing)
3. Ждет 1 секунду для обработки на сервере
4. Загружает полную историю сообщений из API
5. Очищает временные UI элементы
6. Отображает реальные сообщения из API

### Логирование:
Для отладки добавлено подробное логирование:
- `Agent ID changed, loading messages` - при изменении агент ID
- `Cleaning up streaming resources` - при очистке SSE
- `Streaming cleanup complete` - после завершения очистки
- `SSE stream ended naturally` - при корректном завершении потока

## Оптимизация скорости ответа (Update 2)

### Проблема
После отправки сообщения наблюдалась большая задержка перед появлением ответа из-за двойного запроса:
1. POST запрос к `/messages` (ждет полной обработки на бэкенде: 10-30 сек)
2. Дополнительная задержка `setTimeout(1000)` 
3. GET запрос для перезагрузки всей истории сообщений (1-2 сек)

**Итого**: ~12-33 секунды задержки

### Решение
Используем данные из ответа Letta API напрямую вместо перезагрузки истории:

```javascript
// Было:
await chatApi.sendMessageToMessages(...)
await new Promise(resolve => setTimeout(resolve, 1000)) // ❌ лишняя задержка
await loadMessages() // ❌ лишний запрос

// Стало:
const { data } = await chatApi.sendMessageToMessages(...)
// Обрабатываем data напрямую - сообщения уже в ответе! ✅
messages.value.push(...processedMessages)
```

### Результат
- ❌ Убрана задержка в 1 секунду
- ❌ Убран лишний GET запрос на загрузку истории
- ✅ Ответ появляется сразу после обработки на бэкенде
- ✅ Экономия ~2-3 секунды на каждое сообщение

## Deployment

```bash
# Собрать production билд
npm run build

# Файлы готовы к деплою в папке dist/
# Railway автоматически задеплоит изменения при push в main
```

## Заметки

- Если проблемы сохраняются, проверьте консоль браузера на наличие ошибок
- Убедитесь, что переменные окружения правильно настроены на Railway
- При необходимости можно включить streaming режим, передав `{ stream: true }` в опциях при отправке сообщения


